üìú ADR: Arquitectura del Cliente HTTP EcoMarket
Proyecto: Licenciatura en Sistemas Computacionales - UAN

Estatus: Aceptado (Fase de Prototipo)

Contexto: Construcci√≥n de un cliente CRUD robusto que no conf√≠e ciegamente en el servidor.

üèóÔ∏è Decisi√≥n 01: Organizaci√≥n del C√≥digo mediante Funciones
Contexto: El desarrollo inicial de la Semana 2 requiere implementar las 6 operaciones CRUD b√°sicas para EcoMarket. Se busca priorizar la simplicidad mientras se aprenden los fundamentos de comunicaci√≥n.

Decisi√≥n: Utilizar funciones independientes (procedural) en lugar de una estructura de clases.

Alternativas: Crear una clase EcoMarketClient o ProductosClient para encapsular la l√≥gica.

Consecuencias:

Positivas: Curva de aprendizaje baja y c√≥digo f√°cil de seguir secuencialmente.

Negativas: Falta de encapsulamiento; la configuraci√≥n como BASE_URL o TIMEOUT queda como variables globales o se repite, dificultando el mantenimiento a largo plazo.

üîç Decisi√≥n 02: Estrategia de Validaci√≥n de Datos Manual
Contexto: Un cliente robusto debe validar que la respuesta tenga el c√≥digo de estado, tipo de contenido y esquema correctos antes de procesar los datos.

Decisi√≥n: Implementar validaci√≥n manual mediante bloques if/else y l√≥gica personalizada en un m√≥dulo de validadores.

Alternativas: Uso de bibliotecas de esquemas como Pydantic o JSON Schema.

Consecuencias:

Positivas: Comprensi√≥n profunda de las capas de validaci√≥n (Estado -> Content-Type -> Parseo -> Esquema -> Sem√°ntica).

Negativas: El c√≥digo se vuelve verboso y dif√≠cil de escalar si el modelo de datos de EcoMarket se vuelve m√°s complejo (m√°s de 20 endpoints).

üõ°Ô∏è Decisi√≥n 03: Manejo de Excepciones Personalizadas
Contexto: Las excepciones est√°ndar de las librer√≠as (como requests.exceptions) no siempre capturan errores de l√≥gica de negocio o fallos de validaci√≥n espec√≠ficos.

Decisi√≥n: Crear clases de excepci√≥n propias como ValidationError para fallos 4xx y ServerError para fallos 5xx.

Alternativas: Usar response.raise_for_status() de la librer√≠a requests y atrapar excepciones gen√©ricas.

Consecuencias:

Positivas: Manejo de errores m√°s claro y espec√≠fico, permitiendo al cliente diferenciar entre un error del servidor reintentable y un error del cliente definitivo.

Negativas: Requiere un mapeo manual de c√≥digos HTTP a excepciones dentro del flujo de verificaci√≥n de cada funci√≥n.

üîÑ Decisi√≥n que cambiar√≠a tras la reflexi√≥n
Decisi√≥n a cambiar: Ausencia de reintentos autom√°ticos y Timeout fijo.

¬øPor qu√© el cambio? Aunque para una demo un timeout fijo de 10 segundos y fallar al primer intento es aceptable, en un entorno real esto genera una mala experiencia de usuario ante errores transitorios del servidor.

Nueva Propuesta: Implementar un sistema de Exponential Backoff con Jitter para operaciones idempotentes (GET, PUT, DELETE).

Justificaci√≥n: Esto permitir√≠a que el cliente se recupere autom√°ticamente de picos de carga en el servidor sin "bombardearlo" gracias al jitter, previniendo el problema de la thundering herd. Mantendr√≠a la restricci√≥n de no reintentar POST autom√°ticamente para evitar la duplicaci√≥n accidental de recursos (pedidos o productos).